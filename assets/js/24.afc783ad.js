(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{464:function(t,a,r){"use strict";r.r(a);var s=r(35),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"gmp调度模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gmp调度模型"}},[t._v("#")]),t._v(" GMP调度模型")]),t._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#goroutine的优势"}},[t._v("goroutine的优势")])]),r("li",[r("a",{attrs:{href:"#m-n模型"}},[t._v("M:N模型")])]),r("li",[r("a",{attrs:{href:"#概念"}},[t._v("概念")]),r("ul",[r("li",[r("a",{attrs:{href:"#work-stealing"}},[t._v("Work-stealing")])]),r("li",[r("a",{attrs:{href:"#syscall"}},[t._v("Syscall")])]),r("li",[r("a",{attrs:{href:"#spining-thread"}},[t._v("Spining-thread")])]),r("li",[r("a",{attrs:{href:"#sysmon"}},[t._v("Sysmon")])]),r("li",[r("a",{attrs:{href:"#network-poller"}},[t._v("Network-poller")])])])])])]),r("p"),t._v(" "),r("h2",{attrs:{id:"goroutine的优势"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#goroutine的优势"}},[t._v("#")]),t._v(" goroutine的优势")]),t._v(" "),r("ul",[r("li",[t._v("内存占用小，栈默认只有2k，运行过程中如果出现不足会自动扩容，而thread的栈是固定大小的，为了防止溢出会分配比goroutine大得多的栈空间。")]),t._v(" "),r("li",[t._v("创建、销毁及调度开销小，thread需要陷入内核态，线程切换开销也大，goroutine则是用户态完成。")]),t._v(" "),r("li",[t._v("channel通信更安全，thread主要使用共享内存，需要经常使用锁容易踩坑。")])]),t._v(" "),r("h2",{attrs:{id:"m-n模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#m-n模型"}},[t._v("#")]),t._v(" M:N模型")]),t._v(" "),r("p",[t._v("go运行时会创建M个线程，之后创建的N个goroutine就会趋于均匀地调度到这M个线程中执行，N可以远大于M。当然，任一时刻，一个线程只能跑一个goroutine，当goroutine发生阻塞或主动放弃时间片时该线程就会跑别的goroutine。")]),t._v(" "),r("h2",{attrs:{id:"概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),r("ul",[r("li",[t._v("G，就是指goroutine，"),r("code",[t._v("runtime.g")]),t._v("结构表示，包含了当前goroutine的状态、堆栈、上下文。")]),t._v(" "),r("li",[t._v("M，就是内核线程，"),r("code",[t._v("runtime.m")]),t._v("结构表示，所有的M是有线程栈的。")]),t._v(" "),r("li",[t._v("P，早期的实现是没有P的，后面优化引入了逻辑cpu的概念，代表了M所需的上下文环境，全局G队列还是保留，每个P还有个本地队列（CAS实现LockFree），本地队列的G过多的时候会推到全局队列中，阻塞的系统调用返回时找不到空闲的P也会被推到全局队列中。")])]),t._v(" "),r("h3",{attrs:{id:"work-stealing"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#work-stealing"}},[t._v("#")]),t._v(" Work-stealing")]),t._v(" "),r("h3",{attrs:{id:"syscall"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#syscall"}},[t._v("#")]),t._v(" Syscall")]),t._v(" "),r("p",[t._v("调用syscall后会解绑P，然后M和G被阻塞，syscall状态的P是不能跟别的M绑定的，如果短时间内M被唤醒，这个M会优先绑定这个P，有利于数据的局部性，如果某个P的G执行syscall的时间超过sysmon-tick，就会被设置为idle状态，此时便可以被其它的M绑定。")]),t._v(" "),r("p",[t._v("M视角：")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("尝试获取同一个P，恢复执行G")])]),t._v(" "),r("li",[r("p",[t._v("尝试获取并绑定idle list中其它的P，执行其中的G")])]),t._v(" "),r("li",[r("p",[t._v("找不到空闲P，把G放回全局队列，自己回到idle list")])])]),t._v(" "),r("p",[r("strong",[t._v("注意：GOMAXPROCS无法限制使用了阻塞的syscall线程的数量，它只能限制P的数量")])]),t._v(" "),r("h3",{attrs:{id:"spining-thread"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#spining-thread"}},[t._v("#")]),t._v(" Spining-thread")]),t._v(" "),r("ul",[r("li",[t._v("类型1，M不带P的找P挂载（一有P释放就结合）")]),t._v(" "),r("li",[t._v("类型2，M带P的找G运行（一有runable的G就执行）")]),t._v(" "),r("li",[t._v("当有类型1的自旋M存在时，类型2的就不阻塞，因为阻塞会解绑P，立马会被类型1的M抢走")])]),t._v(" "),r("h3",{attrs:{id:"sysmon"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#sysmon"}},[t._v("#")]),t._v(" Sysmon")]),t._v(" "),r("p",[t._v("也叫监控线程，无需P也可以运行，作用有如下几点：")]),t._v(" "),r("ul",[r("li",[t._v("释放闲置超过5分钟的span物理内存")]),t._v(" "),r("li",[t._v("如果超过2分钟没有gc，强制执行")]),t._v(" "),r("li",[t._v("将长时间未处理的netpoll添加到全局队列")]),t._v(" "),r("li",[t._v("向长时间运行的G任务发出抢占调度")]),t._v(" "),r("li",[t._v("收回因syscall长时间阻塞的P")])]),t._v(" "),r("h3",{attrs:{id:"network-poller"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#network-poller"}},[t._v("#")]),t._v(" Network-poller")]),t._v(" "),r("p",[t._v("G发起网络IO操作不会导致M被阻塞，仅仅G被阻塞，从而不会导致大量的M被创建出来。将异步IO转换为阻塞IO的部分称为netpoller，打开或者接受连接都被设置为非阻塞模式，如果试图对其进行IO操作，并且fd还没准备好，G会进入gopark函数，将当前的G状态保存，然后切换到新的G执行。")])])}),[],!1,null,null,null);a.default=e.exports}}]);